/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

/**
 * @file part_b_server.c
 * @author Elif Kızılkaya
 
 * @brief Code for part B for the project EXPLAIN
 *
 *
 * EXPLANATION
 * How to compile and run:
    make
    ./part_a.out blackbox part_a_output.txt
 */

#include "part_b.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
//#include <iostream>
#include <sys/wait.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>


char **
part_b_1_svc(parameters *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */

	//printf("path of executable: %ld \n", strlen(argp->path));
	//printf(" path of executable: %s \n", argp->path);
	int input1 = argp->number1; //Those are sent from client which scanf the commandline
	int input2 = argp->number2;

	/**
     * p2c and c2p are the pipe handles for the parent-to-child and child-to-parent pipes.
     */
    int     p2c[2], c2p[2], nbytes;
    pid_t   pid;
    char w_buffer[1000], r_buffer[10000];  

    /**
     * The parent creates both pipes, which will be shared between the parent and the child.
     */
    pipe(p2c);
    pipe(c2p);

    if((pid=fork()) == -1) {
        fprintf(stderr, "fork() failed.\n");
        exit(-1);
    }

 
    //.......................................................................................................
    if(pid > 0) {
        /**
         * This is the code for the parent process.
         */

        /**
         * The parent should close the ends of the pipes that it will not use.
         */
        close(p2c[0]);    // Parent will not read from p2c
        close(c2p[1]);    // Parent will not write to c2p      
        
        /**
         * Send a request message to the child process.
         * Don't forget to add "1" to the length of the string for the NULL character.
         */

        char buf1[256];

        sprintf(buf1, "%d %d", input1, input2);
        write(p2c[1], buf1, (strlen(buf1) + 1));
        
        /**
         * Now, wait for the response of the child.
         */
       //printf("%lu\n", sizeof(r_buffer));
       //printf("r_buffer: %s\n", r_buffer);
       memset(r_buffer, 0, 10000);
       nbytes = read(c2p[0], r_buffer, sizeof(r_buffer));
       //printf("jsdkjashdk\n");
       //printf("r_buffer: %s\n", r_buffer);
       //printf("nbytes: %d\n", nbytes); //SIL
        /**
         * We will not bother for waiting for the child (no need to worry if the parent 
         * dies before the child responds) since the parent cannot terminate before 
         * the child process sends the response (due to the read() function call.
         */

    
    }
    //.......................................................................................................
    else {
        /**
         * This is the code for the child process.
         */

        /**
         * Wait for the request from the parent.
         */
        char * path1 = argp->path;
        
        //printf(" child path of executable: %s \n", path1);
        
        dup2(p2c[0], STDIN_FILENO);
        dup2(c2p[1], STDOUT_FILENO);
        dup2(c2p[1], STDERR_FILENO);

    
        /**
         * The child can close all pipes since they are not needed anymore. Nothing will happen to stdin, stdout, stderr.
         */
        close(c2p[0]);
        close(c2p[1]);
        close(p2c[0]);
        close(p2c[1]);

    
       // printf("asdsadsa\n");
        execl(path1, "./blackbox", NULL);  
          
    }
    
    result = r_buffer;
    
	return &result;
}
